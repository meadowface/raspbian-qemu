#!/usr/bin/env python3
# The MIT License (MIT)
#
# Copyright (c) 2016 Marc Meadows
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
    test-raspbian-qemu - Tests for the raspbian-qemu tool.

    These run against a test image that is included in source control because
    it requires privileges to create.  To re-create the test image use the
    make-test-image script.

    These tests expect to be run in the same directory as the tool.
"""

import codecs
import collections
import contextlib
from ctypes import LittleEndianStructure, c_ubyte, c_uint, sizeof
import gzip
import hashlib
import importlib.machinery
import io
import os
import socket
import subprocess
import sys
import tarfile
import tempfile
import unittest

TOOL      = "../raspbian-qemu"
TESTIMG   = "test.img"
OTHERIMG  = "other.img"

# Prevent the import of the tool from creating __pycache__ directory and then
# import the tool so we can access it directly as a module for some unit tests.
sys.dont_write_bytecode = True
raspiqemu = importlib.machinery.SourceFileLoader('raspiqemu', TOOL).load_module()

class TestDataCopy(unittest.TestCase):
    """Unit test data_copy() and related functions."""
    SOURCE = "1234567890"
    DEST   = "abcdefghjiklmnopqrstuvwxyz"
    def setUp(self):
        self.tmpdir = tempfile.TemporaryDirectory()

        self.source = os.path.join(self.tmpdir.name, "source")
        with open(self.source, "w") as sourcefile:
            sourcefile.write(self.SOURCE)

        self.dest = os.path.join(self.tmpdir.name, "dest")
        with open(self.dest, "w") as destfile:
            destfile.write(self.DEST)

    def tearDown(self):
        self.tmpdir.cleanup()

    @property
    def source_contents(self):
        """Return the contents of the sourcefile as bytes."""
        with open(self.source) as sourcefile:
            return sourcefile.read()

    @property
    def dest_contents(self):
        """Return the contents of the destfile as bytes."""
        with open(self.dest) as destfile:
            return destfile.read()

    def test_wholefilecopy(self):
        """Simple file copy."""
        raspiqemu.data_copy(self.source, self.dest)
        self.assertEqual(self.dest_contents, self.SOURCE)

    def test_source_offset(self):
        """File copy with source_offset."""
        raspiqemu.data_copy(self.source, self.dest, source_offset=2)
        self.assertEqual(self.dest_contents, self.SOURCE[2:])

    def test_source_offset_same(self):
        """File copy with source_offset into same file."""
        raspiqemu.data_copy(self.source, self.source, source_offset=2)
        self.assertEqual(self.source_contents, self.SOURCE[2:])

    def test_dest_offset(self):
        """File copy with dest_offset."""
        raspiqemu.data_copy(self.source, self.dest, dest_offset=2)
        self.assertEqual(self.dest_contents, self.DEST[:2] + self.SOURCE)

    def test_dest_offset_same(self):
        """File copy with dest_offset into same file."""
        raspiqemu.data_copy(self.source, self.source, dest_offset=2)
        self.assertEqual(self.source_contents, self.SOURCE[:2] + self.SOURCE)

    def test_count(self):
        """File copy with count."""
        raspiqemu.data_copy(self.source, self.dest, count=5)
        self.assertEqual(self.dest_contents, self.SOURCE[:5])

    def test_suffixes(self):
        """Suffix conversion."""
        counts = ((5, "5"),
                  (1024, "1K"),
                  (4096, "4K"),
                  (1024**2, "1M"),
                  (1024**3, "1G"),
                 )

        self.assertIsNone(raspiqemu.resolve_suffix(None))
        self.assertEqual(raspiqemu.resolve_suffix(99), 99)
        for sizeint, sizestr in counts:
            for case in (sizestr.upper(), sizestr.lower()):
                self.assertEqual(raspiqemu.resolve_suffix(case), sizeint)

def read_mbr(image):
    """Read an MBR with ctypes and return it.  Not for general use.  Works
    with the MBRs in the Raspbian images we test, not tested with anything
    else.  Mostly used as a fun second opinion to parted which is used in
    the tool under testing.
    """
    class Partition(LittleEndianStructure):
        """https://en.wikipedia.org/wiki/Master_boot_record#Partition_table_entries"""
        SECTOR_SIZE = 512
        _pack_ = 1
        _fields_ = [("status",    c_ubyte),
                    ("chs_begin", c_ubyte * 3),
                    ("type",      c_ubyte),
                    ("chs_end",   c_ubyte * 3),
                    ("lba_begin", c_uint),
                    ("lba_size",  c_uint),
                   ]

        @property
        def begin(self):
            """Convenience function for returning begin in bytes."""
            return self.lba_begin * self.SECTOR_SIZE

        @property
        def size(self):
            """Convenience function for returning size in bytes."""
            return self.lba_size * self.SECTOR_SIZE
    assert sizeof(Partition) == 16, "Partition definition error"

    class MBR(LittleEndianStructure):
        """https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout"""
        _pack_ = 1
        _fields_ = [("skip",       c_ubyte * 446),
                    ("partitions", Partition * 4),
                    ("signature",  c_ubyte * 2),
                   ]
    assert sizeof(MBR) == 512, "MBR definition error"

    with open(image, "rb") as img:
        mbr = MBR.from_buffer(bytearray(img.read(sizeof(MBR))))
        assert bytes(mbr.signature) == b"\x55\xAA", "Invalid MBR signature."
        return mbr

class TestImageBase(unittest.TestCase):
    """Base class for tests using the included test.img which is created
    with the make-test-image script.
    """
    # This will be there if the hidden --keep-root is passed.
    ROOT_IMG = "root.img"

    # Some files we will be using repeatedly during checks.
    HOSTKEYSTAR      = "test-host-keys.tar"
    REGEN_INITSCRIPT = "/etc/init.d/regenerate_ssh_host_keys"
    AUTHKEYS         = "/home/pi/.ssh/authorized_keys"
    PRELOAD          = "/etc/ld.so.preload"
    SDA_RULES        = "/etc/udev/rules.d/90-qemu-sda.rules"

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Extract the magic strings from the make-test-image script so we only
        # define them in one place and set them as instance variables.
        for line in open("make-test-image"):
            if line.startswith("MAGIC"):
                name, equal, value = line.strip().partition("=")
                if '"' not in value:
                    value = int(value)
                else:
                    value = value.strip('"')
                setattr(self, name, value)

    def setUp(self):
        # Create a shiny new TESTIMG from the included .gz file for each run.
        with gzip.open("test.img.gz") as gz, open(TESTIMG, "wb") as img:
            #NOTE: It's doesn't matter that this slurps everything up into
            #      memory as it's a < 5Mb file.
            img.write(gz.read())

    def tearDown(self):
        os.unlink(TESTIMG)

    def test_read_mbr(self):
        """Sanity check unit test read_mbr() against the test image which
        has a known partition layout.
        (and yes, this is testing code testing testing code)
        """
        mbr = read_mbr(TESTIMG)
        self.assertEqual(mbr.partitions[0].begin, 4096)
        self.assertEqual(mbr.partitions[0].size,  4096)
        self.assertEqual(mbr.partitions[1].begin, 8192)
        self.assertEqual(mbr.partitions[1].size, self.MAGIC_ROOT_SECTORS * 512)

    def callTool(self, args):
        """Call the raspbian-qemu tool with a check for a kept root.img."""
        # Clean up any root images so we can assert whether it's created
        # or not after the run.
        if os.path.exists(self.ROOT_IMG):
            os.unlink(self.ROOT_IMG)

        subprocess.check_output([TOOL] + args, stderr=subprocess.STDOUT)

        # Now make sure root.img was created if request but not if it wasn't.
        # If created correctly, check its state and then clean it up.
        keep_root = "--keep-root" in args
        self.assertEqual(os.path.exists(self.ROOT_IMG), keep_root)
        if keep_root:
            self.assertOnlyUserReadable(self.ROOT_IMG)
            os.unlink(self.ROOT_IMG)

    def runImage(self, image, *, growmode=None, options=[]):
        """Execute the test image pointed to by image, adding any options
        and interact with it according to the growmode if any (see below).

        Returns a RunInfo tuple, see its docstring for description
        of fields.
        """
        class File(tarfile.TarInfo):
            """TarInfo descendant with no changes except that we can add a
            contents attribute. (TarInfo has slots set)"""

        class RunInfo(collections.namedtuple("RunInfo",
                                             ("growmode",
                                              "version",
                                              "bootup",
                                              "files",
                                              "input",
                                              "shutdown"
                                             ))):
            """Data-holder for the results of a running the test image.
                growmode  - which growmode was used.
                version   - version of the test image.
                bootup    - bootup messages on the console.
                files     - a mapping of path to File object.
                input     - any input sent via growmodes.
                shutdown  - shutdown messages on the console.
            """
            pass

        marker = "\n" + self.MAGIC_MARKER + "\n"
        ssh    = "\nHIYA-FROM-SSH\n"

        # Pass in the growmode by growing the root partition that many sectors.
        # First make sure the root partition is an exepcted size.  If it's
        # been grown already, growmode won't work.
        if growmode:
            self.assertEqual(read_mbr(TESTIMG).partitions[1].size,
                             self.MAGIC_ROOT_SECTORS * 512)
            self.callTool(["prep", image, "--grow-root", str(growmode * 512)])

        if growmode == self.MAGIC_GROW_MODE_SSH:
            options += ["--with-ssh-port", "7022"]

        # Run the image using the tool and gather its output.
        # Along the way, select behavior based on the current growmode.
        output = ""
        with subprocess.Popen([TOOL, "run", image] + options,
                               universal_newlines=True,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.DEVNULL) as run:
            try:
                def read_expected_output_byte():
                    """Read a byte from stdout and raise if we don't get one."""
                    output_byte = run.stdout.read(1)
                    if not output_byte:
                        raise ValueError("Unexpected output from run.")
                    return output_byte

                while True:
                    output += read_expected_output_byte()
                    if output.count(marker) == 3:
                        #print("3 MAGIC_MARKERs found", flush=True)
                        break

                if growmode == self.MAGIC_GROW_MODE_SSH:
                    # In this growmode the test image is going to wait for a
                    # connection on the ssh port, display whatever is sent to
                    # that port, and then continue on to clean shutdown.

                    #TODO: Is a race possible here where we try to connect before
                    #TODO: the nc is listening?  Or does the qemu networking
                    #TODO: basically eliminate it by keeping data in transit?
                    #TODO: Putting in a sleep 10 before bringing up the network
                    #TODO: in the test image still worked...
                    #TODO: use timeout in create_connection()
                    with socket.create_connection(("127.0.0.1", 7022)) as s:
                        s.send(ssh.encode())

                    while True:
                        output += read_expected_output_byte()
                        if ssh in output:
                            break
                elif growmode == self.MAGIC_GROW_MODE_INPUT:
                    # In this growmode the test image is going to wait forever
                    # for a line to be input.  Instead, since we're using
                    # mon:stdio, send Ctrl-a 'c' to enter the monitor, then
                    # 'quit<enter>'' to exit the emulator.
                    run.stdin.write("\x01cquit\n")
                    run.stdin.flush()
                    #print("quit sent", flush=True)
                output += run.stdout.read()
            except:
                run.terminate()
                raise

        # The test image will output to stdout the following:
        #   boot up messages
        #   "\n$MAGIC_MARKER\n"
        #   "$MAGIC_VERSION"
        #   "\n$MAGIC_MARKER\n"
        #   a uuencoded tarfile containing the contents of the filesystem
        #   "\n$MAGIC_MARKER\n"
        #   any input sent via growmodes
        #   (The below might not be present in some growmodes.)
        #   "\n$MAGIC_MARKER\n"
        #   shutdown messages

        # Decode the filesystem tar and make a TarFile object out of it.
        sections = output.split(marker)
        bootup, version, uu, ssh = sections[:4]
        shutdown = sections[4] if len(sections) >= 5 else None
        tarbytes = io.BytesIO(codecs.decode(uu.encode(), "uu"))
        tar = tarfile.open(fileobj=tarbytes, tarinfo=File)

        self.assertEqual(version, self.MAGIC_VERSION)

        # Go through the tarfile extracting File objects and populating
        # a .contents member with the contents of each file, finally putting
        # them in a files dictionary to return.
        files = {}
        for file in tar:
            file.contents = tar.extractfile(file)
            if file.contents is not None:
                file.contents = file.contents.read()
            files["/" + file.name] = file

        return RunInfo(growmode, version,
                               bootup, files, ssh, shutdown)

    @contextlib.contextmanager
    def assertImageNotAltered(self, image):
        """Context manager which asserts that the image file is not altered
        during the context."""
        def filehash(filespec):
            """Return the SHA256 hash of filespecs' contents."""
            with open(filespec, "rb") as file:
                return hashlib.sha256(file.read())

        before_hash = filehash(image)
        yield
        after_hash = filehash(image)
        self.assertEqual(before_hash.hexdigest(), after_hash.hexdigest())

    def assertOnlyUserReadable(self, filespec):
        """Assert that only the owner of a file can access it."""
        self.assertEqual(os.stat(filespec).st_mode & 0o077, 0)

class TestPrep(TestImageBase):
    """Check the prep and unprep actions."""
    def assertPrepped(self, image):
        """Perform checks to assert that an image is in a prepped state.
           Returns the results of runImage for further checking.
        """
        runinfo = self.runImage(image)

        self.assertIn(self.SDA_RULES, runinfo.files)

        preload = b"#" + self.MAGIC_PRELOAD.encode() + b"\n"
        self.assertEqual(runinfo.files[self.PRELOAD].contents, preload)

        return runinfo

    def assertUnPrepped(self, image):
        """Perform checks to assert that an image is in a unprepped state.
           Returns the results of runImage for further checking.
        """
        runinfo = self.runImage(image)

        self.assertNotIn(self.SDA_RULES, runinfo.files)

        preload = self.MAGIC_PRELOAD.encode() + b"\n"
        self.assertEqual(runinfo.files[self.PRELOAD].contents, preload)

        # If there are no host keys, then the initscript should be set to
        # generate them.
        if "/etc/ssh/ssh_host_dsa_key" not in runinfo.files:
            initscript = runinfo.files[self.REGEN_INITSCRIPT]
            self.assertIn(b"ssh-keygen", initscript.contents)

        return runinfo

    def test_testimg_starts_unprepped(self):
        """Check that test image is initially unprepped."""
        self.assertUnPrepped(TESTIMG)

    def test_simple_prep(self):
        """Simple prep."""
        self.callTool(["prep", TESTIMG])
        self.assertPrepped(TESTIMG)

    def test_simple_prep_keep_root(self):
        """Simple prep with --keep-root."""
        self.callTool(["--keep-root", "prep", TESTIMG])
        self.assertPrepped(TESTIMG)

    def test_prep_missing_source(self):
        """Prep with missing source file."""
        with self.assertRaises(subprocess.CalledProcessError):
            self.callTool(["--debug", "prep", "missing.img"])

    def test_multi_prep(self):
        """Multiple preps on same image."""
        self.callTool(["prep", TESTIMG])
        self.callTool(["prep", TESTIMG])
        self.assertPrepped(TESTIMG)

    def test_prep_to_dest(self):
        """Prep to a different dest file."""
        with self.assertImageNotAltered(TESTIMG):
            self.callTool(["prep", TESTIMG, OTHERIMG])
            self.assertPrepped(OTHERIMG)
            self.assertOnlyUserReadable(OTHERIMG)
            os.unlink(OTHERIMG)

    def test_simple_unprep(self):
        """Simple unprep."""
        self.callTool(["unprep", TESTIMG])
        self.assertUnPrepped(TESTIMG)

    def test_simple_unprep_keep_root(self):
        """Simple unprep. with --keep-root"""
        self.callTool(["--keep-root", "unprep", TESTIMG])
        self.assertUnPrepped(TESTIMG)

    def test_multi_unprep(self):
        """Multiple unpreps on same image."""
        self.callTool(["unprep", TESTIMG])
        self.callTool(["unprep", TESTIMG])
        self.assertUnPrepped(TESTIMG)

    def test_unprep_to_dest(self):
        """Unprep to a different dest file."""
        self.callTool(["unprep", TESTIMG, OTHERIMG])
        self.assertUnPrepped(OTHERIMG)
        self.assertOnlyUserReadable(OTHERIMG)
        os.unlink(OTHERIMG)

    def test_grow_root(self):
        """Prep with growing root."""
        root_before = read_mbr(TESTIMG).partitions[1].size
        self.callTool(["prep", "--grow-root=1M", TESTIMG])
        root_after = read_mbr(TESTIMG).partitions[1].size
        self.assertEqual(root_after, root_before + 1024**2)

        # Make sure that as well as growing the root, it was prepped too.
        self.assertPrepped(TESTIMG)

    def prep_with_public_key(self, pubkey):
        """prep an image adding a public key with the contents of pubkey."""
        with tempfile.NamedTemporaryFile() as keyfile:
            keyfile.write(pubkey)
            keyfile.flush()
            self.callTool(["prep", "--add-public-key=" + keyfile.name, TESTIMG])

    def test_add_public_key(self):
        """prep --add-public-key."""
        PUBKEY = b"LET ME IN\n"
        self.prep_with_public_key(PUBKEY)
        runinfo = self.assertPrepped(TESTIMG)
        self.assertIn(self.AUTHKEYS, runinfo.files)
        self.assertEqual(runinfo.files[self.AUTHKEYS].contents,
                         PUBKEY)

    def test_add_bad_public_key(self):
        """prep --add-public-key but with a private key file.
        Make sure image isn't altered at all."""
        with self.assertImageNotAltered(TESTIMG):
            with self.assertRaises(subprocess.CalledProcessError):
                self.callTool(["prep", "--add-public-key=", TESTIMG])

    def test_add_bad_private_key(self):
        with self.assertImageNotAltered(TESTIMG):
            with self.assertRaises(subprocess.CalledProcessError):
                self.prep_with_public_key(b"-----BEGIN RSA PRIVATE KEY-----")

    def test_add_duplicate_public_key(self):
        """prep --add-public-key with a duplicate key."""
        PUBKEY = b"LET ME IN\n"
        for attempt in range(2):
            self.prep_with_public_key(PUBKEY)

        runinfo = self.assertPrepped(TESTIMG)
        self.assertIn(self.AUTHKEYS, runinfo.files)
        self.assertEqual(runinfo.files[self.AUTHKEYS].contents,
                         PUBKEY)

    def test_add_multiple_public_keys(self):
        """prep --add-public-key with a multiple keys."""
        PUBKEY_ONE = b"LET ME IN\n"
        PUBKEY_TWO = b"SUDO LET ME IN!\n"
        self.prep_with_public_key(PUBKEY_ONE)
        self.prep_with_public_key(PUBKEY_TWO)

        runinfo = self.assertPrepped(TESTIMG)
        self.assertIn(self.AUTHKEYS, runinfo.files)
        self.assertEqual(runinfo.files[self.AUTHKEYS].contents,
                         PUBKEY_ONE + PUBKEY_TWO)

    def test_set_host_keys(self):
        """prep --set-host-keys.
        Make sure the keys get injected with the right permissions and that
        the initscript is properly altered."""

        self.callTool(["prep", "--set-host-keys=" + self.HOSTKEYSTAR, TESTIMG])

        runinfo = self.assertPrepped(TESTIMG)
        with tarfile.open(self.HOSTKEYSTAR) as tar:
            for member in tar:
                filespec = os.path.join("/etc/ssh", member.name)
                self.assertIn(filespec, runinfo.files)
                self.assertEqual(runinfo.files[filespec].mode, member.mode)
                self.assertEqual(runinfo.files[filespec].uid, member.gid)
                self.assertEqual(runinfo.files[filespec].uid, member.gid)

        initscript = runinfo.files[self.REGEN_INITSCRIPT]
        self.assertNotIn(b"ssh-keygen", initscript.contents)

    @contextlib.contextmanager
    def bad_host_keys(self, alterfunc):
        """Context maager which yields a temp filename of a tarfile that
        is a copy of the self.HOSTKEYSTAR file but with members altered with
        alterfunc."""
        with tempfile.NamedTemporaryFile() as tmptar:
            with tarfile.open(fileobj=tmptar, mode="w") as badtar:
                with tarfile.open(self.HOSTKEYSTAR) as goodtar:
                    for member in goodtar:
                        alterfunc(member)
                        badtar.addfile(member, goodtar.extractfile(member))
                    tmptar.flush()
                    yield tmptar.name

    def test_set_bad_host_keys(self):
        """prep --set-host-keys with a keys with bad permissions."""
        def bad_mode_pub(member):
            if member.name.endswith(".pub"):
                member.mode=0o077
        def bad_mode_private(member):
            if not member.name.endswith(".pub"):
                member.mode=0o077
        def bad_owner(member):
            member.uid = 1000
        def bad_group(member):
            member.gid = 1000

        for alterfunc in (bad_mode_pub, bad_mode_private, bad_owner, bad_group):
            with self.bad_host_keys(alterfunc) as badkeys:
                with self.assertRaises(subprocess.CalledProcessError):
                    with self.assertImageNotAltered(TESTIMG):
                        self.callTool(["prep", "--set-host-keys=" + badkeys,
                                      TESTIMG])


class TestExtract(TestImageBase):
    """Test the extract action."""
    def assertTarfilesEqual(self, afilespec, bfilespec):
        """Check that the contents of tarfiles afilespec and bfilespec
        are the same for the attributes we care about:
            name, uid, gid, mode, size and contents.
        The members do not have to be in the same order.
        """
        with tarfile.open(afilespec) as a, tarfile.open(bfilespec) as b:
            a_members = sorted(a.getmembers(), key=lambda m: m.name)
            b_members = sorted(b.getmembers(), key=lambda m: m.name)

            self.assertEqual(len(a_members), len(b_members))
            for a_member, b_member in zip(a_members, b_members):
                self.assertEqual(a_member.name, b_member.name)
                self.assertEqual(a_member.uid, b_member.uid)
                self.assertEqual(a_member.gid, b_member.gid)
                self.assertEqual(a_member.mode, b_member.mode)
                self.assertEqual(a_member.size, b_member.size)
                a_contents = a.extractfile(a_member).read()
                b_contents = b.extractfile(b_member).read()
                self.assertEqual(a_contents, b_contents)

    def test_no_hostkeys(self):
        """Test extract when there are no host keys."""
        with self.assertRaises(subprocess.CalledProcessError):
            self.callTool(["extract", TESTIMG, "hostkeys", "missing.tar"])

    def test_hostkeys(self):
        """Inject some host keys and then extract, confirming that what we
        extracted is what we injected."""
        EXTRACTED="extracted.tar"
        self.callTool(["prep", "--set-host-keys=" + self.HOSTKEYSTAR, TESTIMG])
        self.callTool(["extract", TESTIMG, "hostkeys", EXTRACTED])
        try:
            self.assertTarfilesEqual(self.HOSTKEYSTAR, EXTRACTED)
            self.assertOnlyUserReadable(EXTRACTED)
        finally:
            os.unlink(EXTRACTED)

    def test_hostkeys_keep_root(self):
        """Simple host keys extraction with --keep-root."""
        EXTRACTED="ignored.tar"
        self.callTool(["prep", "--set-host-keys=" + self.HOSTKEYSTAR, TESTIMG])
        self.callTool(["--keep-root", "extract", TESTIMG, "hostkeys", EXTRACTED])
        os.unlink(EXTRACTED)

class TestBuildKernel(TestImageBase):
    """Test the build-kernel action."""
    def test_build_kernel_no_arg(self):
        """Run build-kernel without a source argument."""
        with self.assertRaises(subprocess.CalledProcessError):
            self.callTool(["build-kernel"])

    def test_build_kernel_bad_arg(self):
        """Run build-kernel with bad source arguments."""
        # Non-existing dir
        with self.assertRaises(subprocess.CalledProcessError):
            self.callTool(["build-kernel", ""])

        # Empty dir
        with tempfile.TemporaryDirectory() as tmpdir:
            with self.assertRaises(subprocess.CalledProcessError):
                self.callTool(["build-kernel", tmpdir])

        # File, not dir
        with self.assertRaises(subprocess.CalledProcessError):
            self.callTool(["build-kernel", TESTIMG])

    def test_build_kernel(self):
        """Build the kernel from a checkout named test-linux.  Easiest
        way is to just symlink test-linux to an existing checkout.

        If test-linux does not exist, this test will be skipped.
        """
        SOURCEDIR="test-linux"
        if os.path.isdir(SOURCEDIR):
            if os.path.isfile(raspiqemu.KERNEL_BINARY):
                os.unlink(raspiqemu.KERNEL_BINARY)
            self.callTool(["build-kernel", SOURCEDIR])
            self.assertTrue(os.path.isfile(raspiqemu.KERNEL_BINARY))
        else:
            print("\n====!!! Skipping build-kernel since test-linux not present !!!====\n")

class TestRun(TestImageBase):
    """Check the run action."""
    def test_monitor_quit(self):
        """run and quit using the monitor."""
        self.runImage(TESTIMG, growmode=self.MAGIC_GROW_MODE_INPUT)

    def test_with_ssh_port(self):
        """run --with-ssh-port."""
        self.runImage(TESTIMG, growmode=self.MAGIC_GROW_MODE_SSH)

    def test_with_display(self):
        """run --with-display.  Only checked if DISPLAY is set.
        (It's up to test runner to confirm a window pops up, it's not checked
        by code.)"""
        #TODO: Put in a headless xserver of some sort and check the window.
        if "DISPLAY" in os.environ and os.environ["DISPLAY"]:
            self.runImage(TESTIMG, options=["--with-display"])

    def test_with_audio(self):
        """run --with-audio.
        (Nothing is really checked except that the switch is accepted and the
        machine boots."""
        self.runImage(TESTIMG, options=["--with-audio"])

if __name__ == "__main__":
    unittest.main(failfast=True)
