#!/usr/bin/env python3
# The MIT License (MIT)
#
# Copyright (c) 2016 Marc Meadows
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
    test-raspbian-qemu - Tests for the raspbian-qemu tool.

    These run against a test image that is included in source control because
    it requires privileges to create.  To re-create the test image use the
    make-test-image script.

    These tests expect to be run in the same directory as the tool.
"""

import codecs
import contextlib
from ctypes import LittleEndianStructure, c_ubyte, c_uint, sizeof
import gzip
import hashlib
import importlib.machinery
import io
import os
import socket
import subprocess
import sys
import tarfile
import tempfile
import unittest

RASPIQEMU = "../raspbian-qemu"
TESTIMG   = "test.img"
OTHERIMG  = "other.img"

# Prevent the import of the tool from creating __pycache__ directory and then
# import the tool so we can access it directly as a module for some unit tests.
sys.dont_write_bytecode = True
raspiqemu = importlib.machinery.SourceFileLoader('raspiqemu', RASPIQEMU).load_module()

class TestDataCopy(unittest.TestCase):
    """Unit test data_copy() and related functions."""
    SOURCE = "1234567890"
    DEST   = "abcdefghjiklmnopqrstuvwxyz"
    def setUp(self):
        self.tmpdir = tempfile.TemporaryDirectory()

        self.source = os.path.join(self.tmpdir.name, "source")
        with open(self.source, "w") as sourcefile:
            sourcefile.write(self.SOURCE)

        self.dest = os.path.join(self.tmpdir.name, "dest")
        with open(self.dest, "w") as destfile:
            destfile.write(self.DEST)

    def tearDown(self):
        self.tmpdir.cleanup()

    @property
    def source_contents(self):
        """Return the contents of the sourcefile as bytes."""
        with open(self.source) as sourcefile:
            return sourcefile.read()

    @property
    def dest_contents(self):
        """Return the contents of the destfile as bytes."""
        with open(self.dest) as destfile:
            return destfile.read()

    def test_wholefilecopy(self):
        """Simple file copy."""
        raspiqemu.data_copy(self.source, self.dest)
        self.assertEqual(self.dest_contents, self.SOURCE)

    def test_source_offset(self):
        """File copy with source_offset."""
        raspiqemu.data_copy(self.source, self.dest, source_offset=2)
        self.assertEqual(self.dest_contents, self.SOURCE[2:])

    def test_source_offset_same(self):
        """File copy with source_offset into same file."""
        raspiqemu.data_copy(self.source, self.source, source_offset=2)
        self.assertEqual(self.source_contents, self.SOURCE[2:])

    def test_dest_offset(self):
        """File copy with dest_offset."""
        raspiqemu.data_copy(self.source, self.dest, dest_offset=2)
        self.assertEqual(self.dest_contents, self.DEST[:2] + self.SOURCE)

    def test_dest_offset_same(self):
        """File copy with dest_offset into same file."""
        raspiqemu.data_copy(self.source, self.source, dest_offset=2)
        self.assertEqual(self.source_contents, self.SOURCE[:2] + self.SOURCE)

    def test_count(self):
        """File copy with count."""
        raspiqemu.data_copy(self.source, self.dest, count=5)
        self.assertEqual(self.dest_contents, self.SOURCE[:5])

    def test_suffixes(self):
        """Suffix conversion."""
        counts = ((5, "5"),
                  (1024, "1K"),
                  (4096, "4K"),
                  (1024**2, "1M"),
                  (1024**3, "1G"),
                 )

        self.assertIsNone(raspiqemu.resolve_suffix(None))
        self.assertEqual(raspiqemu.resolve_suffix(99), 99)
        for sizeint, sizestr in counts:
            for case in (sizestr.upper(), sizestr.lower()):
                self.assertEqual(raspiqemu.resolve_suffix(case), sizeint)

def read_mbr(image):
    """Read an MBR with ctypes and return it.  Not for general use.  Works
    with the MBRs in the Raspbian images we test, not tested with anything
    else.  Mostly used as a fun second opinion to parted which is used in
    the tool under testing.
    """
    class Partition(LittleEndianStructure):
        """https://en.wikipedia.org/wiki/Master_boot_record#Partition_table_entries"""
        SECTOR_SIZE = 512
        _pack_ = 1
        _fields_ = [("status",    c_ubyte),
                    ("chs_begin", c_ubyte * 3),
                    ("type",      c_ubyte),
                    ("chs_end",   c_ubyte * 3),
                    ("lba_begin", c_uint),
                    ("lba_size",  c_uint),
                   ]

        @property
        def begin(self):
            """Convenience function for returning begin in bytes."""
            return self.lba_begin * self.SECTOR_SIZE

        @property
        def size(self):
            """Convenience function for returning size in bytes."""
            return self.lba_size * self.SECTOR_SIZE
    assert sizeof(Partition) == 16, "Partition definition error"

    class MBR(LittleEndianStructure):
        """https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout"""
        _pack_ = 1
        _fields_ = [("skip",       c_ubyte * 446),
                    ("partitions", Partition * 4),
                    ("signature",  c_ubyte * 2),
                   ]
    assert sizeof(MBR) == 512, "MBR definition error"

    with open(image, "rb") as img:
        mbr = MBR.from_buffer(bytearray(img.read(sizeof(MBR))))
        assert bytes(mbr.signature) == b"\x55\xAA", "Invalid MBR signature."
        return mbr

class TestImageBase(unittest.TestCase):
    """Base class for tests using the included test.img which is created
    with the make-test-image script.
    """
    # Extract the magic strings from the make-test-image script so we only
    # define them in one place.
    (MAGIC_BEGIN,
     MAGIC_END,
     MAGIC_PRELOAD) = [line.partition("=")[-1].strip('"\n')
                       for line in open("make-test-image")
                       if line.startswith("MAGIC")]

    # This will be there if the hidden --keep-root is passed.
    ROOT_IMG = "root.img"

    # Some files we will be using repeatedly during checks.
    HOSTKEYSTAR      = "test-host-keys.tar"
    REGEN_INITSCRIPT = "/etc/init.d/regenerate_ssh_host_keys"
    AUTHKEYS         = "/home/pi/.ssh/authorized_keys"
    PRELOAD          = "/etc/ld.so.preload"
    SDA_RULES        = "/etc/udev/rules.d/90-qemu-sda.rules"

    def setUp(self):
        # Create a shiny new TESTIMG from the included .gz file for each run.
        with gzip.open("test.img.gz") as gz, open(TESTIMG, "wb") as img:
            #NOTE: It's doesn't matter that this slurps everything up into
            #      memory as it's a < 5Mb file.
            img.write(gz.read())

    def tearDown(self):
        os.unlink(TESTIMG)

    def test_read_mbr(self):
        """Sanity check unit test read_mbr() against the test image which
        has a known partition layout.
        (and yes, this is testing code testing testing code)
        """
        mbr = read_mbr(TESTIMG)
        self.assertEqual(mbr.partitions[0].begin, 4096)
        self.assertEqual(mbr.partitions[0].size,  4096)
        self.assertEqual(mbr.partitions[1].begin, 8192)
        self.assertEqual(mbr.partitions[1].size,  3137536)

    def runTool(self, args):
        """Run the tool with a check for a kept root.img."""
        # Clean up any root images so we can assert whether it's created
        # or not after the run.
        if os.path.exists(self.ROOT_IMG):
            os.unlink(self.ROOT_IMG)

        subprocess.check_output([RASPIQEMU] + args, stderr=subprocess.STDOUT)

        # Now make sure root.img was created if request but not if it wasn't.
        keep_root = "--keep-root" in args
        self.assertEqual(os.path.exists(self.ROOT_IMG), keep_root)
        if keep_root:
            self.assertOnlyUserReadable(self.ROOT_IMG)

    def runImage(self, image=TESTIMG, sshstr="", options=[]):
        """Return a tuple of:
                kernel output, file mapping, ssh

        Where kernel output is the console output of the kernel on bootup,
        and file mapping is a mapping where the key is a path and the value
        is a File object (see below) for all files in the test image and ssh
        is any data that came in over the ssh port.
        """
        class File(tarfile.TarInfo):
            """TarInfo descendant with no changes except that we can add a
            contents attribute. (TarInfo has slots set)"""

        begin = "\n" + self.MAGIC_BEGIN + "\n"
        end   = "\n" + self.MAGIC_END + "\n"
        ssh   = "\n" + sshstr + "\n"

        if sshstr:
            options += ["--with-ssh-port", "7022"]

        run = subprocess.Popen([RASPIQEMU, "run", image] + options,
                               universal_newlines=True,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.DEVNULL)
        try:
            output = ""
            while True:
                output_byte = run.stdout.read(1)
                if not output_byte:
                    raise ValueError("Unexpected output from run.")
                output += output_byte
                if end in output:
                    #print("MAGIC_END found", flush=True)
                    break

            if sshstr:
                #TODO: Is a race possible here where we try to connect before
                #TODO: the nc is listening?  Or does the qemu networking
                #TODO: basically eliminate it by keeping data in transit?
                #TODO: Putting in a sleep 10 before bringing up the network
                #TODO: in the test image still worked...
                #TODO: use timeout in create_connection()
                with socket.create_connection(("127.0.0.1", 7022)) as s:
                    s.send(ssh.encode())

                while True:
                    output += run.stdout.read(1)
                    if ssh in output:
                        break

            # Since we're using mon:stdio, this is Ctrl-a 'c' to enter the
            # monitor, then 'quit<enter>'' to exit the emulator.
            run.stdin.write("\x01cquit\n")
            run.stdin.close()
            #print("quit sent", flush=True)
            output += run.stdout.read()
            run.stdout.close()
            run.wait()
        except:
            run.terminate()
            raise

        # The test image will output to stdout the following:
        #   kernel boot up
        #   "\n$MAGIC_BEGIN\n"
        #   a uuencoded tarfile containing the contents of the filesystem
        #   "\n$MAGIC_END\n"
        #   "\n$sshstr\n" (if it was sent)

        # Decode the filesystem tar and make a TarFile object out of it.
        kernel, init = output.split(begin)
        uu, ssh = init.split(end)
        tarbytes = io.BytesIO(codecs.decode(uu.encode(), "uu"))
        tar = tarfile.open(fileobj=tarbytes, tarinfo=File)

        # Go through the tarfile extracting File objects and populating
        # a .contents member with the contents of each file, finally putting
        # them in a files dictionary to return.
        files = {}
        for file in tar:
            file.contents = tar.extractfile(file)
            if file.contents is not None:
                file.contents = file.contents.read()
            files["/" + file.name] = file

        return kernel, files, ssh

    @contextlib.contextmanager
    def assert_image_not_altered(self, image):
        """Context manager which asserts that the image file is not altered
        during the context."""
        def filehash(filespec):
            """Return the SHA256 hash of filespecs' contents."""
            with open(filespec, "rb") as file:
                return hashlib.sha256(file.read())

        before_hash = filehash(image)
        yield
        after_hash = filehash(image)
        self.assertEqual(before_hash.hexdigest(), after_hash.hexdigest())

    def assertOnlyUserReadable(self, filespec):
        """Assert that only the owner of a file can access it."""
        self.assertEqual(os.stat(filespec).st_mode & 0o077, 0)

class TestPrep(TestImageBase):
    """Check the prep and unprep actions."""
    def assert_prepped(self, image):
        """Perform checks to assert that an image is in a prepped state.
           Returns the results of runImage for further checking.
        """
        kernel, files, ssh = self.runImage(image)

        self.assertIn(self.SDA_RULES, files)

        preload = b"#" + self.MAGIC_PRELOAD.encode() + b"\n"
        self.assertEqual(files[self.PRELOAD].contents, preload)

        return kernel, files, ssh

    def assert_unprepped(self, image):
        """Perform checks to assert that an image is in a unprepped state.
           Returns the results of runImage for further checking.
        """
        kernel, files, ssh = self.runImage()

        self.assertNotIn(self.SDA_RULES, files)

        preload = self.MAGIC_PRELOAD.encode() + b"\n"
        self.assertEqual(files[self.PRELOAD].contents, preload)

        # If there are no host keys, then the initscript should be set to
        # generate them.
        if "/etc/ssh/ssh_host_dsa_key" not in files:
            initscript = files[self.REGEN_INITSCRIPT]
            self.assertIn(b"ssh-keygen", initscript.contents)

        return kernel, files, ssh

    def test_testimg_starts_unprepped(self):
        """Check that test image is initially unprepped."""
        self.assert_unprepped(TESTIMG)

    def test_simple_prep(self):
        """Simple prep."""
        self.runTool(["prep", TESTIMG])
        self.assert_prepped(TESTIMG)

    def test_simple_prep_keep_root(self):
        """Simple prep with --keep-root."""
        self.runTool(["--keep-root", "prep", TESTIMG])
        self.assert_prepped(TESTIMG)

    def test_prep_missing_source(self):
        """Prep with missing source file."""
        with self.assertRaises(subprocess.CalledProcessError):
            self.runTool(["--debug", "prep", "missing.img"])

    def test_multi_prep(self):
        """Multiple preps on same image."""
        self.runTool(["prep", TESTIMG])
        self.runTool(["prep", TESTIMG])
        self.assert_prepped(TESTIMG)

    def test_prep_to_dest(self):
        """Prep to a different dest file."""
        with self.assert_image_not_altered(TESTIMG):
            self.runTool(["prep", TESTIMG, OTHERIMG])
            self.assert_prepped(OTHERIMG)
            self.assertOnlyUserReadable(OTHERIMG)
            os.unlink(OTHERIMG)

    def test_simple_unprep(self):
        """Simple unprep."""
        self.runTool(["unprep", TESTIMG])
        self.assert_unprepped(TESTIMG)

    def test_simple_unprep_keep_root(self):
        """Simple unprep. with --keep-root"""
        self.runTool(["--keep-root", "unprep", TESTIMG])
        self.assert_unprepped(TESTIMG)

    def test_multi_unprep(self):
        """Multiple unpreps on same image."""
        self.runTool(["unprep", TESTIMG])
        self.runTool(["unprep", TESTIMG])
        self.assert_unprepped(TESTIMG)

    def test_unprep_to_dest(self):
        """Unprep to a different dest file."""
        self.runTool(["unprep", TESTIMG, OTHERIMG])
        self.assert_unprepped(OTHERIMG)
        self.assertOnlyUserReadable(OTHERIMG)
        os.unlink(OTHERIMG)

    def test_grow_root(self):
        """Prep with growing root."""
        root_before = read_mbr(TESTIMG).partitions[1].size
        self.runTool(["prep", "--grow-root=1M", TESTIMG])
        root_after = read_mbr(TESTIMG).partitions[1].size
        self.assertEqual(root_after, root_before + 1024**2)

        # Make sure that as well as growing the root, it was prepped too.
        self.assert_prepped(TESTIMG)

    def prep_with_public_key(self, pubkey):
        """prep an image adding a public key with the contents of pubkey."""
        with tempfile.NamedTemporaryFile() as keyfile:
            keyfile.write(pubkey)
            keyfile.flush()
            self.runTool(["prep", "--add-public-key=" + keyfile.name, TESTIMG])

    def test_add_public_key(self):
        """prep --add-public-key."""
        PUBKEY = b"LET ME IN\n"
        self.prep_with_public_key(PUBKEY)
        kernel, files, ssh = self.assert_prepped(TESTIMG)
        self.assertIn(self.AUTHKEYS, files)
        self.assertEqual(files[self.AUTHKEYS].contents,
                         PUBKEY)

    def test_add_bad_public_key(self):
        """prep --add-public-key but with a private key file.
        Make sure image isn't altered at all."""
        with self.assert_image_not_altered(TESTIMG):
            with self.assertRaises(subprocess.CalledProcessError):
                self.runTool(["prep", "--add-public-key=", TESTIMG])

    def test_add_bad_private_key(self):
        with self.assert_image_not_altered(TESTIMG):
            with self.assertRaises(subprocess.CalledProcessError):
                self.prep_with_public_key(b"-----BEGIN RSA PRIVATE KEY-----")

    def test_add_duplicate_public_key(self):
        """prep --add-public-key with a duplicate key."""
        PUBKEY = b"LET ME IN\n"
        for attempt in range(2):
            self.prep_with_public_key(PUBKEY)

        kernel, files, ssh = self.assert_prepped(TESTIMG)
        self.assertIn(self.AUTHKEYS, files)
        self.assertEqual(files[self.AUTHKEYS].contents,
                         PUBKEY)

    def test_add_multiple_public_keys(self):
        """prep --add-public-key with a multiple keys."""
        PUBKEY_ONE = b"LET ME IN\n"
        PUBKEY_TWO = b"SUDO LET ME IN!\n"
        self.prep_with_public_key(PUBKEY_ONE)
        self.prep_with_public_key(PUBKEY_TWO)

        kernel, files, ssh = self.assert_prepped(TESTIMG)
        self.assertIn(self.AUTHKEYS, files)
        self.assertEqual(files[self.AUTHKEYS].contents,
                         PUBKEY_ONE + PUBKEY_TWO)

    def test_set_host_keys(self):
        """prep --set-host-keys.
        Make sure the keys get injected with the right permissions and that
        the initscript is properly altered."""

        self.runTool(["prep", "--set-host-keys=" + self.HOSTKEYSTAR, TESTIMG])

        kernel, files, ssh = self.assert_prepped(TESTIMG)
        with tarfile.open(self.HOSTKEYSTAR) as tar:
            for member in tar:
                filespec = os.path.join("/etc/ssh", member.name)
                self.assertIn(filespec, files)
                self.assertEqual(files[filespec].mode, member.mode)
                self.assertEqual(files[filespec].uid, member.gid)
                self.assertEqual(files[filespec].uid, member.gid)

        initscript = files[self.REGEN_INITSCRIPT]
        self.assertNotIn(b"ssh-keygen", initscript.contents)

    @contextlib.contextmanager
    def bad_host_keys(self, alterfunc):
        """Context maager which yields a temp filename of a tarfile that
        is a copy of the self.HOSTKEYSTAR file but with members altered with
        alterfunc."""
        with tempfile.NamedTemporaryFile() as tmptar:
            with tarfile.open(fileobj=tmptar, mode="w") as badtar:
                with tarfile.open(self.HOSTKEYSTAR) as goodtar:
                    for member in goodtar:
                        alterfunc(member)
                        badtar.addfile(member, goodtar.extractfile(member))
                    tmptar.flush()
                    yield tmptar.name

    def test_set_bad_host_keys(self):
        """prep --set-host-keys with a keys with bad permissions."""
        def bad_mode_pub(member):
            if member.name.endswith(".pub"):
                member.mode=0o077
        def bad_mode_private(member):
            if not member.name.endswith(".pub"):
                member.mode=0o077
        def bad_owner(member):
            member.uid = 1000
        def bad_group(member):
            member.gid = 1000

        for alterfunc in (bad_mode_pub, bad_mode_private, bad_owner, bad_group):
            with self.bad_host_keys(alterfunc) as badkeys:
                with self.assertRaises(subprocess.CalledProcessError):
                    with self.assert_image_not_altered(TESTIMG):
                        self.runTool(["prep", "--set-host-keys=" + badkeys,
                                      TESTIMG])


class TestExtract(TestImageBase):
    """Test the extract action."""
    def assertTarfilesEqual(self, afilespec, bfilespec):
        """Check that the contents of tarfiles afilespec and bfilespec
        are the same for the attributes we care about:
            name, uid, gid, mode, size and contents.
        The members do not have to be in the same order.
        """
        with tarfile.open(afilespec) as a, tarfile.open(bfilespec) as b:
            a_members = sorted(a.getmembers(), key=lambda m: m.name)
            b_members = sorted(b.getmembers(), key=lambda m: m.name)

            self.assertEqual(len(a_members), len(b_members))
            for a_member, b_member in zip(a_members, b_members):
                self.assertEqual(a_member.name, b_member.name)
                self.assertEqual(a_member.uid, b_member.uid)
                self.assertEqual(a_member.gid, b_member.gid)
                self.assertEqual(a_member.mode, b_member.mode)
                self.assertEqual(a_member.size, b_member.size)
                a_contents = a.extractfile(a_member).read()
                b_contents = b.extractfile(b_member).read()
                self.assertEqual(a_contents, b_contents)

    def test_no_hostkeys(self):
        """Test extract when there are no host keys."""
        with self.assertRaises(subprocess.CalledProcessError):
            self.runTool(["extract", TESTIMG, "hostkeys", "missing.tar"])

    def test_hostkeys(self):
        """Inject some host keys and then extract, confirming that what we
        extracted is what we injected."""
        EXTRACTED="extracted.tar"
        self.runTool(["prep", "--set-host-keys=" + self.HOSTKEYSTAR, TESTIMG])
        self.runTool(["extract", TESTIMG, "hostkeys", EXTRACTED])
        try:
            self.assertTarfilesEqual(self.HOSTKEYSTAR, EXTRACTED)
            self.assertOnlyUserReadable(EXTRACTED)
        finally:
            os.unlink(EXTRACTED)

    def test_hostkeys_keep_root(self):
        """Simple host keys extraction with --keep-root."""
        EXTRACTED="ignored.tar"
        self.runTool(["prep", "--set-host-keys=" + self.HOSTKEYSTAR, TESTIMG])
        self.runTool(["--keep-root", "extract", TESTIMG, "hostkeys", EXTRACTED])
        os.unlink(EXTRACTED)

class TestBuildKernel(TestImageBase):
    """Test the build-kernel action."""
    def test_build_kernel_no_arg(self):
        """Run build-kernel without a source argument."""
        with self.assertRaises(subprocess.CalledProcessError):
            self.runTool(["build-kernel"])

    def test_build_kernel_bad_arg(self):
        """Run build-kernel with bad source arguments."""
        # Non-existing dir
        with self.assertRaises(subprocess.CalledProcessError):
            self.runTool(["build-kernel", ""])

        # Empty dir
        with tempfile.TemporaryDirectory() as tmpdir:
            with self.assertRaises(subprocess.CalledProcessError):
                self.runTool(["build-kernel", tmpdir])

        # File, not dir
        with self.assertRaises(subprocess.CalledProcessError):
            self.runTool(["build-kernel", TESTIMG])

    def test_build_kernel(self):
        """Build the kernel from a checkout named test-linux.  Easiest
        way is to just symlink test-linux to an existing checkout.

        If test-linux does not exist, this test will be skipped.
        """
        SOURCEDIR="test-linux"
        if os.path.isdir(SOURCEDIR):
            if os.path.isfile(raspiqemu.KERNEL_BINARY):
                os.unlink(raspiqemu.KERNEL_BINARY)
            self.runTool(["build-kernel", SOURCEDIR])
            self.assertTrue(os.path.isfile(raspiqemu.KERNEL_BINARY))
        else:
            print("\n====!!! Skipping build-kernel since test-linux not present !!!====\n")

class TestRun(TestImageBase):
    """Check the run action."""
    def test_with_ssh_port(self):
        """run --with-ssh-port."""
        tag = "HELLO-FROM-SSH"
        kernel, files, ssh = self.runImage(TESTIMG, tag)
        self.assertIn(tag, ssh)

    def test_with_display(self):
        """run --with-display.  Only checked if DISPLAY is set.
        (It's up to test runner to confirm a window pops up, it's not checked
        by code.)"""
        #TODO: Put in a headless xserver of some sort and check the window.
        if "DISPLAY" in os.environ and os.environ["DISPLAY"]:
            kernel, files, ssh = self.runImage(TESTIMG, options=["--with-display"])

    def test_with_audio(self):
        """run --with-audio.
        (Nothing is really checked except that the switch is accepted and the
        machine boots."""
        kernel, files, ssh = self.runImage(TESTIMG, options=["--with-audio"])

if __name__ == "__main__":
    unittest.main(failfast=True)
